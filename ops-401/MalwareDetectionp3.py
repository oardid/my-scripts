#!/usr/bin/python3

""""
# Script Name:                  ops401-challenge33
# Author:                       Omar Ardid
# Date of latest revision:      06/12/2024
# Purpose:                      Incorporating VirusTotal
# Resources:                    https://github.com/codefellows/seattle-cybersecurity-401d12/blob/main/class-33/challenges/DEMO.md
#                               https://github.com/eduardxyz/virustotal-search
#                               https://www.tines.com/blog/virustotal-api-security-automation

Description:
This script allows a user to search for a specific file by name within a specified directory.
For each file found, it calculates the MD5 hash and checks it against VirusTotal's API to
retrieve the number of malicious detections. The user is prompted for a VirusTotal API key,
which can be stored in an environment variable 'API_KEY_VIRUSTOTAL' for future use.

Dependencies:
- hashlib module (for MD5 hashing)
- requests module (for making HTTP requests to VirusTotal API)
- threading module (for multi-threading to handle search operation)

Functions:
- animated_text(text): Displays animated text in the console.
- search_file(file_name, search_directory, api_key): Searches for a file by name in the specified directory.
  For each found file, it calculates MD5 hash, prints file details, and checks against VirusTotal.
- generate_md5(file_path): Generates MD5 hash for a given file.
- check_virustotal(file_hash, api_key, retries=3): Checks VirusTotal for number of malicious detections
  based on the provided file hash.
- prompt_for_api_key(): Prompts user to enter VirusTotal API key. Recursively prompts until a valid key is provided.
- main(): Main function that initializes the search process based on user inputs (file name, directory).
"""

# Import necessary libraries/modules
import os, sys, time, hashlib, requests, threading

# Define the VirusTotal API URL
API_URL = 'https://www.virustotal.com/api/v3/files/'

# Function to display animated text
def animated_text(text):
    # Define frames for animation
    animation_frames = ["|", "/", "-", "\\"]
    # Loop to animate text with frames
    for _ in range(5):
        for frame in animation_frames:
            # Print animated text with frame, overwrite previous text
            print(f"\r{text} {frame}", end="", flush=True)
            time.sleep(0.1)  # Delay for animation effect
    print()  # Print newline after animation

# Function to search for a file in a directory
def search_file(file_name, search_directory, api_key):
    hits = 0  # Counter for number of hits
    files_searched = 0  # Counter for total files searched
    found_files = []  # List to store found files

    try:
        # Walk through the directory tree
        for root, dirs, files in os.walk(search_directory):
            for file in files:
                files_searched += 1  # Increment files searched counter
                # Check if file_name (case insensitive) is in file (case insensitive)
                if file_name.lower() in file.lower():
                    hits += 1  # Increment hit counter
                    file_path = os.path.join(root, file)  # Get full file path
                    file_size = os.path.getsize(file_path)  # Get file size in bytes
                    timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())  # Get current timestamp
                    md5_hash = generate_md5(file_path)  # Get MD5 hash of the file
                    print("")  # Print empty line
                    # Print file details
                    print(f"Timestamp: {timestamp}")
                    print(f"File: {file}")
                    print(f"Path: {file_path}")
                    print(f"Size: {file_size} bytes")
                    print(f"MD5: {md5_hash}")
                    print("-" * 40)  # Print separator line
                    positives = check_virustotal(md5_hash, api_key)  # Check VirusTotal for file hash
                    if positives is not None:
                        print(f"VirusTotal Positives: {positives}")  # Print VirusTotal results
                        detailed_report = check_virustotal(md5_hash, api_key, get_report=True)  # Get detailed report URL
                        if detailed_report:
                            print(f"Detailed Report: {detailed_report}")  # Print detailed report URL
                        else:
                            print(f"(‡∏á ‚Ä¢ÃÄ_‚Ä¢ÃÅ)‡∏á Detailed report not available for {file}")
                    else:
                        # Handle UnicodeEncodeError by encoding to sys.stdout.encoding
                        encoded_hash = md5_hash.encode(sys.stdout.encoding, errors='replace').decode(sys.stdout.encoding)
                        print(f"(‡∏á ‚Ä¢ÃÄ_‚Ä¢ÃÅ)‡∏á File not found on VirusTotal: {encoded_hash}")  # Print if file not found on VirusTotal
                    print("-" * 40)  # Print separator line
                    found_files.append((file, md5_hash, positives))  # Append found file details to list
    except Exception as e:
        # Handle UnicodeEncodeError in exception message
        encoded_error = str(e).encode(sys.stdout.encoding, errors='replace').decode(sys.stdout.encoding)
        print(f"(‡∏á ‚Ä¢ÃÄ_‚Ä¢ÃÅ)‡∏á An error occurred: {encoded_error}")  # Print error message
    
    # Print search completion message
    print(f"\n(„Å£Ôºæ‚ñøÔºæ)üí® Search completed. {files_searched} files searched. {hits} hits found.")
    input("\n  ï‚Ä¢ÃÅ·¥•‚Ä¢ÃÄ î„Å£ Press Enter to exit.")  # Wait for user to press Enter


# Function to generate the MD5 hash of a file
def generate_md5(file_path):
    hash_md5 = hashlib.md5()  # Create MD5 hash object
    try:
        with open(file_path, "rb") as f:  # Open file in binary mode
            for chunk in iter(lambda: f.read(4096), b""):  # Read file in chunks of 4096 bytes
                hash_md5.update(chunk)  # Update MD5 hash with current chunk
    except Exception as e:
        # Handle UnicodeEncodeError in exception message
        encoded_error = str(e).encode(sys.stdout.encoding, errors='replace').decode(sys.stdout.encoding)
        print(f"(‡∏á ‚Ä¢ÃÄ_‚Ä¢ÃÅ)‡∏á Error reading file {file_path}: {encoded_error}")  # Print error message
        return None  # Return None if error occurs
    return hash_md5.hexdigest()  # Return MD5 hash digest as hexadecimal string

def check_virustotal(file_hash, api_key, retries=3, get_report=False):
    headers = {
        'x-apikey': api_key  # Set API key header
    }
    url = f'{API_URL}{file_hash}'  # Construct API URL with file hash
    for attempt in range(retries):  # Retry loop
        response = requests.get(url, headers=headers)  # Send GET request to VirusTotal API
        if response.status_code == 200:  # If successful response
            result = response.json()  # Parse JSON response
            if 'data' in result and 'attributes' in result['data']:
                if get_report:
                    # Get detailed report URL from VirusTotal
                    detailed_report_url = result['data']['attributes'].get('last_analysis_results', {}).get('verbose_msg', 'No detailed report available')
                    return detailed_report_url  # Return detailed report URL
                else:
                    # Get number of malicious detections from VirusTotal
                    positives = result['data']['attributes'].get('last_analysis_stats', {}).get('malicious', 0)
                    return positives  # Return number of positives
            else:
                print(f"(‡∏á ‚Ä¢ÃÄ_‚Ä¢ÃÅ)‡∏á No VirusTotal results for {file_hash}")  # Print if no results found
                return None  # Return None if no results found
        elif response.status_code == 204:  # If rate limit exceeded
            print(f"(‡∏á ‚Ä¢ÃÄ_‚Ä¢ÃÅ)‡∏á Rate limit exceeded. Retrying in 15 seconds...")  # Print rate limit message
            time.sleep(15)  # Wait 15 seconds before retrying
        elif response.status_code == 404:  # If file not found on VirusTotal
            return None  # Return None if file not found
        else:
            print(f"(‡∏á ‚Ä¢ÃÄ_‚Ä¢ÃÅ)‡∏á Error querying VirusTotal: {response.status_code}")  # Print error message
            return None  # Return None for other errors
    return None  # Return None if retries exhausted

# Function to prompt for VirusTotal API key
def prompt_for_api_key():
    api_key = input("Enter your VirusTotal API key: ").strip()  # Prompt user for API key
    if not api_key:  # If API key is empty
        print("(‡∏á ‚Ä¢ÃÄ_‚Ä¢ÃÅ)‡∏á API key cannot be empty. Please provide a valid VirusTotal API key.")  # Print error message
        return prompt_for_api_key()  # Recursively prompt for API key
    return api_key  # Return valid API key

# Main function
def main():
    operating_system = sys.platform  # Get current operating system
    if operating_system.startswith('linux') or operating_system.startswith('win32'):
        animated_text(f"Running on {operating_system.capitalize()}...  ï‚Ä¢ÃÅ·¥•‚Ä¢ÃÄ î„Å£")  # Print animated text with OS name
        file_name = input("Enter the file name to search for: ")  # Prompt user for file name
        search_directory = input("Enter the directory to search in: ")  # Prompt user for directory
        if not os.path.exists(search_directory):  # If directory does not exist
            # Handle UnicodeEncodeError in directory not found message
            encoded_error = f"The specified directory '{search_directory}' does not exist.".encode(sys.stdout.encoding, errors='replace').decode(sys.stdout.encoding)
            print(f"(‡∏á ‚Ä¢ÃÄ_‚Ä¢ÃÅ)‡∏á {encoded_error}")  # Print error message
            return  # Exit function
    else:
        print("(‡∏á ‚Ä¢ÃÄ_‚Ä¢ÃÅ)‡∏á Unsupported operating system.")  # Print error message
        return  # Exit function

    # Prompt user for VirusTotal API key
    api_key = os.getenv('API_KEY_VIRUSTOTAL')  # Get API key from environment variable
    if not api_key:  # If API key is not set
        api_key = prompt_for_api_key()  # Prompt user for API key
        os.environ['API_KEY_VIRUSTOTAL'] = api_key  # Set environment variable with API key

    search_thread = threading.Thread(target=search_file, args=(file_name, search_directory, api_key))  # Create search thread
    search_thread.start()  # Start search thread
    search_thread.join()  # Wait for search thread to complete

if __name__ == "__main__":
    main()  # Execute main function if script is run directly